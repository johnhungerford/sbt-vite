package sbtvite.sbtplugin

import org.scalajs.jsenv.Input
import org.scalajs.sbtplugin.ScalaJSPlugin
import org.scalajs.sbtplugin.ScalaJSPlugin.autoImport.*
import sbt.*
import sbt.Keys.*
import sbt.nio.Keys.*
import sbtvite.{NpmExecutor, NpmNpmExecutor, SourceInjector, ViteConfigGen}

import scala.util.Try

object SbtVitePlugin extends AutoPlugin {

	override def requires: Plugins = ScalaJSPlugin

	object autoImport {
		// Configuration types

		type Location = sbtvite.config.Location
		val Location: sbtvite.config.Location.type = sbtvite.config.Location

		type DependencyManagement = sbtvite.config.DependencyManagement
		val DependencyManagement: sbtvite.config.DependencyManagement.type =
			sbtvite.config.DependencyManagement

		type NpmManager = sbtvite.config.NpmManager
		val NpmManager: sbtvite.config.NpmManager.type =
			sbtvite.config.NpmManager

		// Public keys

		/**
		 * Specify whether and how to manage npm dependencies, and in general controls
		 * much of the behavior of sbt-vite.
		 *
		 * [[DependencyManagement.Manual]]:
		 *   - User will manage dependencies using package manager of choice. Vite will
		 *     not install any modules.
		 *   - Vite will be executed relative to [[viteProjectRoot]], and
		 *     [[viteOtherSources]] will be ignored. I.e., no sources will be copied to
		 *     a build directory or processed in any way for building. Any required
		 *     sources must therefore be resolvable from [[viteProjectRoot]].
		 *   - This is recommended if you want to use a JS package manager to manage
		 *     all dependencies and you don't want sbt mutating `package.json`. You will
		 *     need to manually install any packages required for any functionality your
		 *     sbt-vite configuration enables, however. (At a minimum this will require
		 *     installing vite.)
		 *
		 * [[DependencyManagement.InstallOnly]]:
		 *   - Same as [[DependencyManagement.Manual]] except that sbt-vite will install
		 *     dependencies from [[npmDependencies]] and [[npmDevDependencies]] at
		 *     [[viteProjectRoot]]
		 *   - This is recommended is you want to manage dependencies using a JS package
		 *     manager to manage dependencies for your project, but you don't want to be
		 *     responsible for installing the packages required by sbt. Note that this will
		 *     change `package.json` and `node_modules` at [[viteProjectRoot]]
		 *
		 * [[DependencyManagement.Managed]]:
		 *   - Dependencies will be fully managed by sbt-vite. All npm dependencies
		 *     imported in the project must be included in [[npmDependencies]]. All
		 *     non-Scala.js sources must be identified in [[viteOtherSources]].
		 *   - No project files will be mutated. All sources from [[viteOtherSources]]
		 *     will be copied to a separate build directory where npm dependencies will
		 *     also be installed.
		 *   - Recommended if you want to control everything from sbt and keep your
		 *     project clean of JS tooling (e.g., package.json, node_modules).
		 *
		 * @see [[DependencyManagement]]
		 */
		val viteDependencyManagement = settingKey[DependencyManagement](
			"How to manage npm dependencies: manually, install-only (semi-manually), or fully automated",
		)

		/**
		 * Where vite will run and install dependencies for "manual" or "install-only"
		 * dependency management. Ignored for "managed" dependency management.
		 *
		 * @see [[Location]]
		 */
		val viteProjectRoot = settingKey[Location](
			"Where to run vite and install dependencies for \"manual\" or \"install-only\" dependency management.",
		)

		/**
		 * Where vite will persist its build when fully optimized. Defaults to:
		 * [project-dir]/target/scala-[x.x.x]/sbt-vite-prod/bundle/
		 *
		 * @see [[Location]]
		 */
		val viteProdBundleLocation = settingKey[Location](
			"Location of fully optimized bundle generated by vite"
		)

		/**
		 * Where vite will persist its un-optimized (dev) build. Defaults to:
		 * [project-dir]/target/scala-[x.x.x]/sbt-vite-dev/bundle/
		 *
		 * @see [[Location]]
		 */
		val viteDevBundleLocation = settingKey[Location](
			"Location of unoptimized (fast) bundle generated by vite"
		)

		/**
		 * Where generated vite configuration for fully optimized builds will be kept.
		 * Defaults to: [project-dir]/target/scala-[x.x.x]/sbt-vite-prod/vite.config.js
		 */
		val viteProdConfigLocation = settingKey[Location](
			"Location of generated vite config for fully optimized (production) builds"
		)

		/**
		 * Where generated vite configuration for un-optimized (dev) builds will be kept.
		 * Defaults to: [project-dir]/target/scala-[x.x.x]/sbt-vite-full/vite.config.js
		 */
		val viteDevConfigLocation = settingKey[Location](
			"Location of generated vite config for un-optimized (development) builds"
		)

		/**
		 * Locations of vite configuration files for overriding default vite test
		 * configuration. These should have the same form as any vite configuration
		 * javascript file except that it should not be wrapped in `defineConfig`.
		 * Instead it should export (default) either a simple `UserConfig` object or a
		 * function from `ConfigEnv` to `UserConfig`. See source:
		 * https://github.com/vitejs/vite/blob/main/packages/vite/src/node/config.ts
		 */
		val viteProdConfigSources = settingKey[Seq[Location]](
			"Locations of vite configuration files for overriding default vite test configuration",
		)

		/**
		 * Locations of vite configuration files for overriding default vite test
		 * configuration. These should have the same form as any vite configuration
		 * javascript file except that it should not be wrapped in `defineConfig`.
		 * Instead it should export (default) either a simple `UserConfig` object or a
		 * function from `ConfigEnv` to `UserConfig`. See source:
		 * https://github.com/vitejs/vite/blob/main/packages/vite/src/node/config.ts
		 */
		val viteDevConfigSources = settingKey[Seq[Location]](
			"Locations of vite configuration files for overriding default vite test configuration",
		)

		/**
		 * Additional sources to be bundled with Scala.js when dependency management is
		 * "managed". Ignored for "manual" and "install-only".
		 *
		 * If a source [[Location]] points to a directory, everything within that directory
		 * will be copied to the build root directory. This means that when importing any
		 * module within such a location, the directory itself should be omitted.
		 *
		 * For instance, if `[project-root]/src/typescript` is one of the locations, and you
		 * want to import from some file
		 * `[project-root]/src/typescript/someModule/someObject.ts`, would use:
		 *
		 * `@JSImport("/someModule/someObject", JSImport.Default)` (for Scala.js)
		 *
		 * or
		 *
		 * `import someObject from '/someModule/someObject';` (for JS).
		 *
		 * If a source [[Location]] points to a non-directory file, that file will
		 * be copied to the build root directory. This means that if one of the
		 * locations is `[project-root]/my-artifacts/index.css`, you can import that
		 * simply as:
		 *
		 * `@JSImport("/index.css?inline", JSImport.Namespace)` (for Scala.js)
		 *
		 * or
		 *
		 * `import '/index.css';` (for JS)
		 */
		val viteOtherSources = settingKey[Set[Location]](
			"Locations of non-scala sources for \"managed\" dependency management",
		)

		/**
		 * Version of vite to use if dependency management is "install-only" or "managed".
		 * Otherwise ignored.
		 */
		val viteVersion = settingKey[String](
			"Version of vite to use, for \"install-only\" or \"auto\" dependency management",
		)

		/**
		 * Npm dependencies to be installed if dependency management is "install-only"
		 * or "managed". Each tuple should have the form `(package, version)` as they
		 * as they would be written in a `package.json` file
		 * (e.g. `{ ..."dependencies": { ... "[package]": "[version]" ... } ... }`)
		 */
		val npmDependencies = settingKey[Seq[(String, String)]](
			"npm dependencies to be installed when using \"install-only\" or \"auto\" dependency management",
		)

		/**
		 * Npm dev dependencies to be installed if dependency management is "install-only"
		 * or "managed". Each tuple should have the form `(package, version)` as they
		 * as they would be written in a `package.json` file
		 * (e.g. `{ ..."devDependencies": { ... "[package]": "[version]" ... } ... }`)
		 */
		val npmDevDependencies = settingKey[Seq[(String, String)]](
			"npm development dependencies to be installed when using \"install-only\" or \"auto\" dependency management",
		)

		/**
		 * Npm dev dependencies to be installed if dependency management is "install-only"
		 * or "managed". Each tuple should have the form `(package, version)` as they
		 * as they would be written in a `package.json` file
		 * (e.g. `{ ..."devDependencies": { ... "[package]": "[version]" ... } ... }`)
		 */
		val npmPeerDependencies = settingKey[Seq[(String, String)]](
			"npm development dependencies to be installed when using \"install-only\" or \"auto\" dependency management",
		)

		/**
		 * Npm dev dependencies to be installed if dependency management is "install-only"
		 * or "managed". Each tuple should have the form `(package, version)` as they
		 * as they would be written in a `package.json` file
		 * (e.g. `{ ..."devDependencies": { ... "[package]": "[version]" ... } ... }`)
		 */
		val npmOtherDependencies = settingKey[Seq[(String, String)]](
			"npm development dependencies to be installed when using \"install-only\" or \"auto\" dependency management",
		)

		/**
		 * Environment variable definitions to be used when running `vite`
		 */
		val viteEnvironment = settingKey[Map[String, String]](
			"Environment variables to be used when running vite",
		)

		/**
		 * Environment variable definitions to be used when running `vite`
		 */
		val viteProdEnvironment = settingKey[Map[String, String]](
			"Environment variables to be used when running vite",
		)

		/**
		 * Environment variable definitions to be used when running `vite`
		 */
		val viteDevEnvironment = settingKey[Map[String, String]](
			"Environment variables to be used when running vite",
		)

		/**
		 * Arguments or options to be included when running `vite`
		 */
		val viteExtraArgs = settingKey[Seq[String]](
			"Additional arguments/options to use when running vite build",
		)

		/**
		 * Arguments or options to be included when running `vite`
		 */
		val viteProdExtraArgs = settingKey[Seq[String]](
			"Additional arguments/options to use when running vite build",
		)

		/**
		 * Arguments or options to be included when running `vite`
		 */
		val viteDevExtraArgs = settingKey[Seq[String]](
			"Additional arguments/options to use when running vite build",
		)

		/**
		 * Environment variable definitions to be used when running the `npm`
		 * command
		 */
		val npmEnvironment = settingKey[Map[String, String]](
			"Environment variables to be used when running npm install",
		)


		/**
		 * Arguments or options to be included when running `npm install`
		 */
		val npmExtraArgs = settingKey[Seq[String]](
			"Additional arguments/options to use when running npm install",
		)


		/**
		 * Environment variable definitions to be used when running the `yarn`
		 * command
		 */
		val yarnEnvironment = settingKey[Map[String, String]](
			"Environment variables to be used when running yarn",
		)


		/**
		 * Arguments or options to be included when running `yarn add`
		 */
		val yarnExtraArgs = settingKey[Seq[String]](
			"Additional arguments/options to use when running yarn add",
		)


		val pnpmEnvironment = settingKey[Map[String, String]](
			"Environment variables to be used when running pnpm",
		)

		/**
		 * Arguments or options to be included when running `pnpm add`
		 */
		val pnpmExtraArgs = settingKey[Seq[String]](
			"Additional arguments/options to use when running pnpm install",
		)

		/**
		 * When true, do not generate a vite config. Instead, vite commands will
		 * simply run in [[viteProjectRoot]] without explicitly specifying a vite
		 * config.
		 */
		val viteUseExistingConfig = settingKey[Boolean](
			"Skip config generation and assume existing vite.config.js at viteProjectRoot",
		)

		/**
		 * Where to persist the vite dev server script generated by viteGenerateDevServerScript.
		 * Defaults to project root.
		 */
		val viteDevServerScriptLocation = settingKey[Location](
			"Where to persist the vite dev server script generated by viteGenerateDevServerScript"
		)

		// Public tasks

		/**
		 * Install all dependencies if using "install-only" or "managed" dependency
		 * management. Ignored otherwise.
		 */
		val viteInstallDependenciesProd = taskKey[Unit](
			"Install npm packages defined in npmDependencies and npmDevDependencies",
		)

		/**
		 * Install all dependencies if using "install-only" or "managed" dependency
		 * management. Ignored otherwise.
		 */
		val viteInstallDependenciesDev = taskKey[Unit](
			"Install npm packages defined in npmDependencies and npmDevDependencies",
		)

		/**
		 * Generates and persists bundle from Scala.js and other sources. Depends
		 * on [[viteGenerateProdConfig]] and [[viteInstallDependenciesProd]].
		 */
		val viteBuildProd = taskKey[Unit](
			"Run vite build on all web artifacts",
		)

		/**
		 * Generates and persists bundle from Scala.js and other sources. Depends
		 * on [[viteGenerateDevConfig]] and [[viteInstallDependenciesProd]].
		 */
		val viteBuildDev = taskKey[Unit](
			"Run vite build on all web artifacts",
		)

		/**
		 * Starts a vite development server. Depends
		 * * on [[viteGenerateDevConfig]] and [[viteInstallDependenciesProd]].
		 */
		val viteDevServer = taskKey[Unit](
			"Start a development server using vite"
		)

		/**
		 * Generates a script to start the vite dev server without needing to run
		 * sbt. Script will be place in viteDevServerScriptLocation
		 */
		val viteGenerateDevServerScript = taskKey[Unit](
			"Generate a script to start a vite dev server without using sbt"
		)
	}

	// Private settings

	private[sbtvite] val viteProdTargetDirectory = SettingKey[File](
		"viteProdTargetDirectory",
		"Directory where vite prod build artifacts will be persisted",
		KeyRanks.Invisible,
	)

	private[sbtvite] val viteDevTargetDirectory = SettingKey[File](
		"viteDevTargetDirectory",
		"Directory where vite dev build artifacts will be persisted",
		KeyRanks.Invisible,
	)

	private[sbtvite] val viteProdExecutionDirectory = SettingKey[File](
		"viteProdExecutionDirectory",
		"Directory where vite will be run for prod builds",
		KeyRanks.Invisible,
	)

	private[sbtvite] val viteDevExecutionDirectory = SettingKey[File](
		"viteDevExecutionDirectory",
		"Directory where vite will be run for dev builds",
		KeyRanks.Invisible,
	)

	private[sbtvite] val viteBundleDirectoryName = SettingKey[String](
		"viteBundleDirectoryName",
		"Name of the directory where the generated bundle is stored",
		KeyRanks.Invisible,
	)

	private [sbtvite] val viteProdBundleDirectory = SettingKey[File](
		"viteProdBundleDirectory",
		"Directory where the generated bundle is stored",
		KeyRanks.Invisible,
	)

	private [sbtvite] val viteDevBundleDirectory = SettingKey[File](
		"viteDevBundleDirectory",
		"Directory where the generated bundle is stored",
		KeyRanks.Invisible,
	)

	private[sbtvite] val viteConfigName = SettingKey[String](
		"viteConfigName",
		"Filename of the generated vite configuration",
		KeyRanks.Invisible,
	)

	private [sbtvite] val viteTestBundleDirectoryName = SettingKey[String](
		"viteTestBundleDirectoryName",
		"Name of the directory where the compiled test code will be placed when bundling tests",
		KeyRanks.Invisible,
	)

	private [sbtvite] val viteTestBundleEntrypoint = SettingKey[File](
		"viteTestEntrypoint",
		"Compiled test file to be bundled into test executable",
		KeyRanks.Invisible,
	)

	private [sbtvite] val viteScalajsDirectoryName = SettingKey[String](
		"viteScalajsDirectoryName",
		"Name of the directory where the compiled scalajs will be placed during build",
		KeyRanks.Invisible,
	)

	private [sbtvite] val viteProdScalajsEntrypoint = SettingKey[File](
		"viteProdScalajsEntrypoint",
		"Compiled scalajs file to be bundled into full build",
		KeyRanks.Invisible,
	)

	private [sbtvite] val viteDevScalajsEntrypoint = SettingKey[File](
		"viteDevScalajsEntrypoint",
		"Compiled scalajs file to be bundled into full build",
		KeyRanks.Invisible,
	)

	private [sbtvite] val viteTestConfigName = SettingKey[String](
		"viteTestConfigName",
		"Vite test config filename",
		KeyRanks.Invisible,
	)

	private [sbtvite] val viteTestConfigFile = SettingKey[File](
		"viteTestConfigFile",
		"Vite test config file",
		KeyRanks.Invisible,
	)

	private [sbtvite] val viteScalajsTestDirectoryName = SettingKey[String](
		"viteScalajsTestDirectoryName",
		"Vite test config file",
		KeyRanks.Invisible,
	)
	private [sbtvite] val viteTestScalajsEntrypoint = SettingKey[File](
		"viteTestScalajsEntrypoint",
		"Vite test config file",
		KeyRanks.Invisible,
	)

	// Private tasks

	/**
	 * Generate and persists vite configuration file for full (prod) builds.
	 */
	private[sbtvite] val viteGenerateProdConfig = TaskKey[Unit](
		"viteGenerateProdConfig",
		"Generate and persists vite configuration file for full (prod) builds.",
		KeyRanks.Invisible,
	)

	/**
	 * Generate and persists vite configuration file for fast (dev) builds.
	 */
	private[sbtvite] val viteGenerateDevConfig = TaskKey[Unit](
		"viteGenerateDevConfig",
		"Generate and persists vite configuration file for fast (dev) builds.",
		KeyRanks.Invisible,
	)

	/**
	 * Generate and persists vite configuration file for fast (dev) builds.
	 */
	private[sbtvite] val viteGenerateTestConfig = TaskKey[Unit](
		"viteGenerateTestConfig",
		"Generate and persists vite configuration file for fast (dev) builds.",
		KeyRanks.Invisible,
	)

	/**
	 * Moves sources to the build directory, if dependency management is
	 * set to "managed"
	 */
	private[sbtvite] val vitePrepareProdSources = TaskKey[Unit](
		"vitePrepareProdSources",
		"Moves sources to the build directory, if dependency management is set to \"managed\"",
		KeyRanks.Invisible,
	)

	/**
	 * Moves sources to the build directory, if dependency management is
	 * set to "managed"
	 */
	private[sbtvite] val vitePrepareDevSources = TaskKey[Unit](
		"vitePrepareDevSources",
		"Moves sources to the build directory, if dependency management is set to \"managed\"",
		KeyRanks.Invisible,
	)

	/**
	 * Moves sources to the build directory, if dependency management is
	 * set to "managed"
	 */
	private[sbtvite] val vitePrepareTestSources = TaskKey[Unit](
		"vitePrepareTestSources",
		"Moves sources to the build directory, if dependency management is set to \"managed\"",
		KeyRanks.Invisible,
	)

	/**
	 * Moves sources to the build directory, if dependency management is
	 * set to "managed"
	 */
	private[sbtvite] val viteBuildTest = TaskKey[Unit](
		"viteBuildTest",
		"Bundles executable test",
		KeyRanks.Invisible,
	)

	import autoImport.*

	override lazy val projectSettings = Seq(
		viteDependencyManagement := DependencyManagement.Managed(NpmManager.Npm),

		viteVersion := "^4.4.9",

		viteProjectRoot := Location.ProjectRoot,

		viteUseExistingConfig := false,

		viteProdConfigSources := Nil,
		viteOtherSources := Set.empty,

		npmDependencies := Nil,
		npmDevDependencies :=
			Seq(
				"vite" -> viteVersion.value,
				"lodash" -> "^4.17.21",
				"rollup-plugin-sourcemaps" -> "^0.6.3",
			),
		viteEnvironment := Map.empty,
		npmEnvironment := Map.empty,
		yarnEnvironment := Map.empty,
		pnpmEnvironment := Map.empty,
		viteExtraArgs := Nil,
		npmExtraArgs := Nil,
		yarnExtraArgs := Nil,
		pnpmExtraArgs := Nil,

		viteProdTargetDirectory :=
		  target.value / s"scala-${scalaVersion.value}" / "sbt-vite-prod",

		viteDevTargetDirectory :=
		  target.value / s"scala-${scalaVersion.value}" / "sbt-vite-dev",

		viteProdExecutionDirectory := {
			viteDependencyManagement.value match {
				case DependencyManagement.Managed(_) =>
					viteProdTargetDirectory.value
				case _ =>
					viteProjectRoot.value.resolve(file("."), baseDirectory.value)
			}
		},

		viteDevExecutionDirectory := {
			viteDependencyManagement.value match {
				case DependencyManagement.Managed(_) =>
					viteDevTargetDirectory.value
				case _ =>
					viteProjectRoot.value.resolve(file("."), baseDirectory.value)
			}
		},

		viteTestBundleDirectoryName := viteBundleDirectoryName.value + "-test",

		viteScalajsDirectoryName := "__scalajs",

		viteScalajsTestDirectoryName := viteScalajsDirectoryName.value + "-test",

		viteProdConfigLocation :=
		  Location.FromCwd(viteProdTargetDirectory.value / viteConfigName.value),

		viteDevConfigLocation :=
		  Location.FromCwd(viteDevTargetDirectory.value / viteConfigName.value),

		viteTestConfigFile :=
		  viteDevExecutionDirectory.value / viteTestConfigName.value,

		viteBundleDirectoryName := "bundle",

		viteProdBundleDirectory :=
		  viteProdTargetDirectory.value / viteBundleDirectoryName.value,

		viteProdBundleLocation := Location.FromCwd(viteProdBundleDirectory.value),

		viteDevBundleDirectory :=
		  viteDevTargetDirectory.value / viteBundleDirectoryName.value,

		viteDevBundleLocation := Location.FromCwd(viteDevBundleDirectory.value),

		viteTestBundleEntrypoint := {
			viteDevTargetDirectory.value / viteTestBundleDirectoryName.value / "main.js"
		},

		viteProdScalajsEntrypoint := {
			viteDependencyManagement.value match {
				case DependencyManagement.Managed(_) =>
					viteProdExecutionDirectory.value / viteScalajsDirectoryName.value / "main.js"
				case _ =>
					(Compile / fullLinkJS / scalaJSLinkerOutputDirectory).value / "main.js"
			}
		},

		viteDevScalajsEntrypoint := {
			viteDependencyManagement.value match {
				case DependencyManagement.Managed(_) =>
					viteDevExecutionDirectory.value / viteScalajsDirectoryName.value / "main.js"
				case _ =>
					(Compile / fastLinkJS / scalaJSLinkerOutputDirectory).value / "main.js"
			}
		},

		viteTestScalajsEntrypoint := {
			viteDependencyManagement.value match {
				case DependencyManagement.Managed(_) =>
					viteDevTargetDirectory.value / viteScalajsTestDirectoryName.value / "main.js"
				case _ =>
					(Test / fastLinkJS / scalaJSLinkerOutputDirectory).value / "main.js"
			}
		},

		viteConfigName := "vite.config.js",

		viteTestConfigName := "vite.config-test.js",

		viteTestConfigFile :=
		  viteDevTargetDirectory.value / viteTestConfigName.value,

		viteOtherSources := viteOtherSources.value,

		npmDependencies := Nil,

		viteEnvironment := Map.empty,
		viteProdEnvironment := Map.empty,
		viteDevEnvironment := Map(
			"NODE_ENV" -> "development",
		),

		viteExtraArgs := Nil,
		viteProdExtraArgs := Nil,
		viteDevExtraArgs := Nil,

		viteProdConfigSources := Nil,
		viteDevConfigSources := Nil,

		viteDevServerScriptLocation := Location.ProjectRoot,

		viteInstallDependenciesProd := {
			viteDependencyManagement.value match {
				case DependencyManagement.Manual => {}
				case DependencyManagement.InstallOnly(manager) =>
					val executor = NpmExecutor(manager)
					val dependencies = npmDependencies.value.toMap
					val devDependencies = npmDevDependencies.value.toMap
					val cwd = Some(viteProjectRoot.value.resolve(file("."), baseDirectory.value))
					val (options, environment) = manager match {
						case NpmManager.Yarn =>
							yarnExtraArgs.value -> yarnEnvironment.value
						case NpmManager.Npm =>
							npmExtraArgs.value -> npmEnvironment.value
						case NpmManager.Pnpm =>
							pnpmExtraArgs.value -> pnpmEnvironment.value
					}
					executor.install(dependencies, devDependencies, options, environment, cwd) match {
						case Left(msg) => new MessageOnlyException(msg)
						case _ => ()
					}

				case DependencyManagement.Managed(manager) =>
					val packageJson = """{ "type": "module" }"""
					val executor = NpmExecutor(manager)
					val dependencies = npmDependencies.value.toMap
					val devDependencies = npmDevDependencies.value.toMap
					val execDirectory = viteProdTargetDirectory.value
					val cwd = Some(execDirectory)
					import scala.sys.process._

					cwd.foreach(IO.createDirectory)
					Process("mkdir node_modules", cwd).run.exitValue()
					IO.write(execDirectory / "package.json", packageJson.getBytes())
					val (options, environment) = manager match {
						case NpmManager.Yarn =>
							yarnExtraArgs.value -> yarnEnvironment.value
						case NpmManager.Npm =>
							npmExtraArgs.value -> npmEnvironment.value
						case NpmManager.Pnpm =>
							pnpmExtraArgs.value -> pnpmEnvironment.value
					}
					executor
					  .install(dependencies, devDependencies, options, environment, cwd) match {
						case Left(msg) => new MessageOnlyException(msg)
						case _ => ()
					}
			}
		},

		viteInstallDependenciesDev := {
			viteDependencyManagement.value match {
				case DependencyManagement.Manual => {}
				case DependencyManagement.InstallOnly(manager) =>
					val executor = NpmExecutor(manager)
					val dependencies = npmDependencies.value.toMap
					val devDependencies = npmDevDependencies.value.toMap
					val cwd = Some(viteProjectRoot.value.resolve(file("."), baseDirectory.value))
					val (options, environment) = manager match {
						case NpmManager.Yarn =>
							yarnExtraArgs.value -> yarnEnvironment.value
						case NpmManager.Npm =>
							npmExtraArgs.value -> npmEnvironment.value
						case NpmManager.Pnpm =>
							pnpmExtraArgs.value -> pnpmEnvironment.value
					}
					executor.install(dependencies, devDependencies, options, environment, cwd) match {
						case Left(msg) => new MessageOnlyException(msg)
						case _ => ()
					}

				case DependencyManagement.Managed(manager) =>
					val packageJson = """{ "type": "module" }"""
					val executor = NpmExecutor(manager)
					val dependencies = npmDependencies.value.toMap
					val devDependencies = npmDevDependencies.value.toMap
					val execDirectory = viteDevTargetDirectory.value
					val cwd = Some(execDirectory)
					import scala.sys.process._

					cwd.foreach(IO.createDirectory)
					Process("mkdir node_modules", cwd).run.exitValue()
					IO.write(execDirectory / "package.json", packageJson.getBytes())
					val (options, environment) = manager match {
						case NpmManager.Yarn =>
							yarnExtraArgs.value -> yarnEnvironment.value
						case NpmManager.Npm =>
							npmExtraArgs.value -> npmEnvironment.value
						case NpmManager.Pnpm =>
							pnpmExtraArgs.value -> pnpmEnvironment.value
					}
					executor
					  .install(dependencies, devDependencies, options, environment, cwd) match {
						case Left(msg) => new MessageOnlyException(msg)
						case _ => ()
					}
			}
		},

		viteGenerateProdConfig := {
			if (viteUseExistingConfig.value) {}
			else {
				val rootDirPath = viteProdExecutionDirectory.value
				val outDir = viteProdBundleDirectory.value.toPath.toAbsolutePath
				val linkOutputDir = viteProdExecutionDirectory
				  .value
				  .relativize(
					viteProdScalajsEntrypoint
					  .value
					  .getParentFile
				  ).get

				val requiredImports = List(
					"""import _ from 'lodash'""",
					"""import { defineConfig } from "vite";""",
					"""import scalaJSPlugin from "./customVitePlugin";"""
				)

				val plugins = List(
					s"""scalaJSPlugin('$linkOutputDir')""",
				)

				val configString =
					ViteConfigGen.generate(
						viteProdConfigSources.value.toList.map(_.resolve(file("."), baseDirectory.value).toString),
						rootDirPath.toString,
						None,
						outDir.toString,
						requiredImports,
						plugins,
						development = false,
					).fold(err => throw new IllegalArgumentException(err.message), identity)

				val configFile = (Compile / viteProdConfigLocation)
				  .value
				  .resolve(file("."), baseDirectory.value)

				val customPluginSource =
					scala.io.Source.fromInputStream(
						getClass.getClassLoader.getResourceAsStream("customVitePlugin.ts")
					).mkString

				val customPluginFile = configFile.getParentFile / "customVitePlugin.ts"

				IO.write(configFile, configString)
				IO.write(customPluginFile, customPluginSource)
			}
		},

		viteGenerateDevConfig := {
			if (viteUseExistingConfig.value) {}
			else {
				val rootDirPath = viteDevExecutionDirectory.value
				val outDir = viteDevBundleDirectory.value.toPath.toAbsolutePath
				val linkOutputDir = viteDevExecutionDirectory
				  .value
				  .relativize(
					  viteDevScalajsEntrypoint
						.value
						.getParentFile
				  ).get

				val requiredImports = List(
					"""import _ from 'lodash'""",
					"""import { defineConfig } from "vite";""",
					"""import scalaJSPlugin from "./customVitePlugin";"""
				)

				val plugins = List(
					s"""scalaJSPlugin('$linkOutputDir')""",
				)

				val configString =
					ViteConfigGen.generate(
						viteDevConfigSources.value.toList.map(_.resolve(file("."), baseDirectory.value).toString),
						rootDirPath.toString,
						None,
						outDir.toString,
						requiredImports,
						plugins,
						development = false,
					).fold(err => throw new IllegalArgumentException(err.message), identity)

				val configFile = viteDevConfigLocation
				  .value
				  .resolve(file("."), baseDirectory.value)

				val customPluginSource =
					scala.io.Source.fromInputStream(
						getClass.getClassLoader.getResourceAsStream("customVitePlugin.ts")
					).mkString

				val customPluginFile = configFile.getParentFile / "customVitePlugin.ts"

				IO.write(configFile, configString)
				IO.write(customPluginFile, customPluginSource)
			}
		},

		viteGenerateTestConfig := {
			val rootDirPath = viteDevExecutionDirectory.value.toPath
			val outDir = viteTestBundleEntrypoint.value.toPath.getParent.toAbsolutePath
			val input = viteDevExecutionDirectory
			  .value
			  .relativize(
				  viteTestScalajsEntrypoint
					.value
			  ).get

			val linkOutDir = viteDevExecutionDirectory
			  .value
			  .relativize(
				  viteDevScalajsEntrypoint
					.value
					.getParentFile
			  ).get

			val requiredImports = List(
				"""import _ from 'lodash'""",
				"""import { defineConfig } from "vite";""",
				"""import sourcemaps from 'rollup-plugin-sourcemaps';""",
				"""import scalaJSPlugin from "./customVitePlugin";""",
			)

			val configString =
				ViteConfigGen.generate(
					viteDevConfigSources.value.toList.map(_.resolve(file("."), baseDirectory.value).toString),
					rootDirPath.toString,
					Some(input.toString),
					outDir.toString,
					requiredImports,
					List(s"""scalaJSPlugin('$linkOutDir')"""),
					List("sourcemaps()"),
				).fold(err => throw new IllegalArgumentException(err.message), identity)

			val configFile = viteTestConfigFile.value

			val customPluginFile = configFile.getParentFile / "customVitePlugin.ts"

			val customPluginSource =
				scala.io.Source.fromInputStream(
					getClass.getClassLoader.getResourceAsStream("customVitePlugin.ts")
				).mkString

			IO.write(configFile, configString)
			IO.write(customPluginFile, customPluginSource)
		},

		vitePrepareProdSources / fileInputs := {
			val sources = (Compile / fullLinkJS / scalaJSLinkerOutputDirectory)
			  .value +: {
				viteOtherSources
				  .value
				  .toList
				  .map(_.resolve(file("."), baseDirectory.value))
			}

			val globs = SourceInjector.impl.sourceGlobs(sources)
			globs.foreach(println)
			globs
		},

		vitePrepareProdSources := {
			if (
				vitePrepareProdSources.inputFileChanges.hasChanges
			)
				viteDependencyManagement.value match {
					case DependencyManagement.Manual => {}
					case DependencyManagement.InstallOnly(_) => {}
					case DependencyManagement.Managed(_) =>
						val injector = SourceInjector.impl
						val sources = viteOtherSources
						  .value
						  .toList
						  .map(_.resolve(file("."), baseDirectory.value))

						val target = viteProdExecutionDirectory.value

						injector.inject(sources, target) match {
							case Right(_) => {}
							case Left(msg) =>
								throw new MessageOnlyException(msg)
						}

						val scalajsSource = (Compile / fullLinkJS / scalaJSLinkerOutputDirectory)
						  .value
						val scalajsTarget = viteProdScalajsEntrypoint.value.getParentFile

						injector.inject(Seq(scalajsSource), scalajsTarget)
				}
		},

		vitePrepareProdSources := vitePrepareProdSources
		  .dependsOn(Compile / fullLinkJS).value,

		vitePrepareDevSources / fileInputs := {
			val sources = (Compile / fastLinkJS / scalaJSLinkerOutputDirectory)
			  .value +: {
				viteOtherSources
				  .value
				  .toList
				  .map(_.resolve(file("."), baseDirectory.value))
			}

			val globs = SourceInjector.impl.sourceGlobs(sources)
			globs.foreach(println)
			globs
		},

		vitePrepareDevSources := {
			if (
				vitePrepareDevSources.inputFileChanges.hasChanges
			)
				viteDependencyManagement.value match {
					case DependencyManagement.Manual => {}
					case DependencyManagement.InstallOnly(_) => {}
					case DependencyManagement.Managed(_) =>
						val injector = SourceInjector.impl
						val sources = viteOtherSources
						  .value
						  .toList
						  .map(_.resolve(file("."), baseDirectory.value))

						val target = viteDevExecutionDirectory.value

						injector.inject(sources, target) match {
							case Right(_) => {}
							case Left(msg) =>
								throw new MessageOnlyException(msg)
						}

						val scalajsSource = (Compile / fastLinkJS / scalaJSLinkerOutputDirectory)
						  .value
						val scalajsTarget = viteDevScalajsEntrypoint.value.getParentFile

						injector.inject(Seq(scalajsSource), scalajsTarget)
				}
		},

		vitePrepareDevSources := vitePrepareDevSources
		  .dependsOn(Compile / fastLinkJS).value,

		vitePrepareTestSources := {
			viteDependencyManagement.value match {
				case DependencyManagement.Manual => {}
				case DependencyManagement.InstallOnly(_) => {}
				case DependencyManagement.Managed(_) =>
					val injector = SourceInjector.impl

					val testsSource = (Test / fastLinkJS / scalaJSLinkerOutputDirectory)
					  .value
					val testsTarget = viteTestScalajsEntrypoint.value.getParentFile

					injector.inject(Seq(testsSource), testsTarget)
			}
		},

		vitePrepareTestSources := vitePrepareTestSources
		  .dependsOn(
			  vitePrepareDevSources,
			  Test / fastLinkJS,
		  ).value,

		viteBuildProd / fileInputs ++= Seq(
			viteProdExecutionDirectory.value.absolutePath.stripSuffix("/") + "/**",
		),

		viteBuildProd := {
			// Only bundle if there is a new configuration, there are new test compilation outputs
			// or the bundled output is missing
			if ( {
				viteBuildProd.inputFileChanges.hasChanges
			} || {
				Try(IO
				  .read(
					  viteProdBundleLocation.value
						.resolve(file("."), baseDirectory.value)
				  ),
				).isFailure
			}) {
				val configPath = viteProdConfigLocation
				  .value
				  .resolve(file("."), baseDirectory.value)
				  .toPath
				  .toString
				val viteCwd = viteProdExecutionDirectory.value
				val npmEnv = npmEnvironment.value
				val yarnEnv = yarnEnvironment.value
				val pnpmEnv = pnpmEnvironment.value
				val packageAndModule = "vite"
				val viteArgs = viteExtraArgs.value ++ viteProdExtraArgs.value
				val viteEnv = viteEnvironment.value ++ viteProdEnvironment.value

				val (executor, managerOpt) = viteDependencyManagement.value match {
					case DependencyManagement.Manual =>
						(NpmNpmExecutor, None)
					case DependencyManagement.InstallOnly(manager) =>
						(NpmExecutor(manager), Some(manager))
					case DependencyManagement.Managed(manager) =>
						(NpmExecutor(manager), Some(manager))
				}

				val command =
					if (viteUseExistingConfig.value)
						s"build" +: viteArgs
					else s"build -c $configPath" +: viteArgs

				val managerEnv = viteEnv ++ (managerOpt match {
					case None => Nil
					case Some(NpmManager.Npm) => npmEnv
					case Some(NpmManager.Yarn) => yarnEnv
					case Some(NpmManager.Pnpm) => pnpmEnv
				})

				val result = executor.run(
					packageAndModule,
					packageAndModule,
					command,
					viteEnv ++ managerEnv,
					Some(viteCwd),
				)

				result match {
					case Right(_) => {}
					case Left(message) =>
						throw new MessageOnlyException(message)
				}
			} else {}
		},

		viteBuildProd := viteBuildProd
		  .dependsOn(
			  viteGenerateProdConfig,
			  viteInstallDependenciesProd,
			  vitePrepareProdSources,
		  )
		  .value,

		viteBuildDev / fileInputs ++= Seq(
			viteDevExecutionDirectory.value.absolutePath.stripSuffix("/") + "/**",
		),

		viteBuildDev := {
			// Only bundle if there is a new configuration, there are new test compilation outputs
			// or the bundled output is missing
			if ( {
				viteBuildDev.inputFileChanges.hasChanges
			} || {
				Try(IO
				  .read(
					  viteDevBundleLocation.value
						.resolve(file("."), baseDirectory.value)
				  ),
				).isFailure
			}) {
				val configPath = viteDevConfigLocation
				  .value
				  .resolve(file("."), baseDirectory.value)
				  .toPath
				  .toString
				val viteCwd = viteDevExecutionDirectory.value
				val npmEnv = npmEnvironment.value
				val yarnEnv = yarnEnvironment.value
				val pnpmEnv = pnpmEnvironment.value
				val packageAndModule = "vite"
				val viteArgs = viteExtraArgs.value ++ viteDevExtraArgs.value
				val viteEnv = viteEnvironment.value ++ viteDevEnvironment.value

				val (executor, managerOpt) = viteDependencyManagement.value match {
					case DependencyManagement.Manual =>
						(NpmNpmExecutor, None)
					case DependencyManagement.InstallOnly(manager) =>
						(NpmExecutor(manager), Some(manager))
					case DependencyManagement.Managed(manager) =>
						(NpmExecutor(manager), Some(manager))
				}

				val command =
					if (viteUseExistingConfig.value)
						s"build" +: viteArgs
					else s"build -c $configPath" +: viteArgs

				val managerEnv = viteEnv ++ (managerOpt match {
					case None => Nil
					case Some(NpmManager.Npm) => npmEnv
					case Some(NpmManager.Yarn) => yarnEnv
					case Some(NpmManager.Pnpm) => pnpmEnv
				})

				val result = executor.run(
					packageAndModule,
					packageAndModule,
					command,
					viteEnv ++ managerEnv,
					Some(viteCwd),
				)

				result match {
					case Right(_) => {}
					case Left(message) =>
						throw new MessageOnlyException(message)
				}
			} else {}
		},

		viteBuildDev := viteBuildDev
		  .dependsOn(
			  viteGenerateDevConfig,
			  viteInstallDependenciesDev,
			  vitePrepareDevSources,
		  )
		  .value,

		viteBuildTest / fileInputs := {
			(viteBuildDev / fileInputs).value
		},

		viteBuildTest := {
			if ( {
				viteBuildTest.inputFileChanges.hasChanges
			} || {
				Try(IO
				  .read(viteTestBundleEntrypoint.value),
				).isFailure
			}) {
				val configPath = viteTestConfigFile
				  .value
				  .toPath
				  .toString
				val viteCwd = viteDevExecutionDirectory.value
				val npmEnv = npmEnvironment.value
				val yarnEnv = yarnEnvironment.value
				val pnpmEnv = pnpmEnvironment.value
				val packageAndModule = "vite"
				val viteArgs = viteExtraArgs.value ++ viteDevExtraArgs.value
				val viteEnv = viteEnvironment.value ++ viteDevEnvironment.value

				val (executor, managerOpt) = viteDependencyManagement.value match {
					case DependencyManagement.Manual =>
						(NpmNpmExecutor, None)
					case DependencyManagement.InstallOnly(manager) =>
						(NpmExecutor(manager), Some(manager))
					case DependencyManagement.Managed(manager) =>
						(NpmExecutor(manager), Some(manager))
				}

				val command = s"build -c $configPath" +: viteArgs

				val managerEnv = viteEnv ++ (managerOpt match {
					case None => Nil
					case Some(NpmManager.Npm) => npmEnv
					case Some(NpmManager.Yarn) => yarnEnv
					case Some(NpmManager.Pnpm) => pnpmEnv
				})

				val result = executor.run(
					packageAndModule,
					packageAndModule,
					command,
					viteEnv ++ managerEnv,
					Some(viteCwd),
				)

				result match {
					case Right(_) => {}
					case Left(message) =>
						throw new MessageOnlyException(message)
				}
			} else {}
		},

		viteBuildTest := viteBuildTest
		  .dependsOn(
			  viteGenerateTestConfig,
			  viteInstallDependenciesDev,
			  vitePrepareTestSources,
		  )
		  .value,

		viteDevServer := {
			val configPath = viteDevConfigLocation
			  .value
			  .resolve(file("."), baseDirectory.value)
			  .toPath
			  .toString
			val viteCwd = viteDevExecutionDirectory
			  .value
			val npmEnv = npmEnvironment.value
			val yarnEnv = yarnEnvironment.value
			val pnpmEnv = pnpmEnvironment.value
			val packageAndModule = "vite"
			val viteArgs = viteExtraArgs.value
			val viteEnv = viteEnvironment.value

			val (executor, managerOpt) = viteDependencyManagement.value match {
				case DependencyManagement.Manual =>
					(NpmNpmExecutor, None)
				case DependencyManagement.InstallOnly(manager) =>
					(NpmExecutor(manager), Some(manager))
				case DependencyManagement.Managed(manager) =>
					(NpmExecutor(manager), Some(manager))
			}

			val command =
				if (viteUseExistingConfig.value)
					viteArgs
				else s"-c $configPath" +: viteArgs

			val managerEnv = viteEnv ++ (managerOpt match {
				case None => Nil
				case Some(NpmManager.Npm) => npmEnv
				case Some(NpmManager.Yarn) => yarnEnv
				case Some(NpmManager.Pnpm) => pnpmEnv
			})

			val process = executor.runProcess(
				packageAndModule,
				packageAndModule,
				command,
				viteEnv ++ managerEnv,
				Some(viteCwd),
			)

			scala.io.StdIn.readLine("Running vite dev server. Press enter to close")
			println("Closing dev server...")
			while (process.isAlive()) {
				process.destroy()
			}
			println("...Closed")
			process.exitValue()
		},

		viteDevServer := viteDevServer
		  .dependsOn(
			  viteGenerateDevConfig,
			  vitePrepareDevSources,
			  viteInstallDependenciesDev,
		  ).value,

		viteGenerateDevServerScript := {
			val scriptDir = viteDevServerScriptLocation.value
				.resolve(file("."), baseDirectory.value)

			val scriptFileName = "start-dev-server.sh"

			val scriptFile = scriptDir / scriptFileName

			val executionDirPath =
				viteDevExecutionDirectory.value.toPath.toAbsolutePath

			val configPath = viteDevConfigLocation
			  .value
			  .resolve(file("."), baseDirectory.value)
			  .toPath
			  .toAbsolutePath

			val script =
				s"""#!/bin/sh
				   |
				   |set -m
				   |original_dir=$$(pwd)
				   |cd $executionDirPath
				   |npx -p vite vite -c ${configPath} &
				   |cd $$original_dir
				   |fg %1
				   |""".stripMargin

			IO.write(scriptFile, script)
			IO.chmod("rwxr-x---", scriptFile)
		},

		viteGenerateDevServerScript := viteGenerateDevServerScript
		  .dependsOn(
			  viteInstallDependenciesDev,
			  vitePrepareDevSources,
			  viteGenerateDevConfig,
		  ).value,

		Test / test := (Test / test).dependsOn(viteBuildTest).value,

		Test / jsEnvInput := List(
			Input.Script(
				(Test / viteTestBundleEntrypoint).value.toPath,
			),
		),

		jsEnvInput := List(
			Input.Script(
				viteDevScalajsEntrypoint
				  .value
				  .toPath
			),
		),
	)
}
