package sbtvite.sbtplugin

import org.scalajs.jsenv.Input
import org.scalajs.sbtplugin.ScalaJSPlugin
import org.scalajs.sbtplugin.ScalaJSPlugin.autoImport.*
import sbt.*
import sbt.Keys.*
import sbt.nio.Keys.*
import sbtvite.{NpmExecutor, NpmNpmExecutor, SourceInjector, ViteConfigGen}

import scala.util.Try

object SbtVitePlugin extends AutoPlugin {

	override def requires: Plugins = ScalaJSPlugin

	object autoImport {
		// Configuration types

		type Location = sbtvite.config.Location
		val Location: sbtvite.config.Location.type = sbtvite.config.Location

		type DependencyManagement = sbtvite.config.DependencyManagement
		val DependencyManagement: sbtvite.config.DependencyManagement.type =
			sbtvite.config.DependencyManagement

		type NpmManager = sbtvite.config.NpmManager
		val NpmManager: sbtvite.config.NpmManager.type =
			sbtvite.config.NpmManager

		// Public keys

		/**
		 * Specify whether and how to manage npm dependencies, and in general controls
		 * much of the behavior of sbt-vite.
		 *
		 * [[DependencyManagement.Manual]]:
		 *   - User will manage dependencies using package manager of choice. Vite will
		 *     not install any modules.
		 *   - Vite will be executed relative to [[viteProjectRoot]], and
		 *     [[viteOtherSources]] will be ignored. I.e., no sources will be copied to
		 *     a build directory or processed in any way for building. Any required
		 *     sources must therefore be resolvable from [[viteProjectRoot]].
		 *   - This is recommended if you want to use a JS package manager to manage
		 *     all dependencies and you don't want sbt mutating `package.json`. You will
		 *     need to manually install any packages required for any functionality your
		 *     sbt-vite configuration enables, however. (At a minimum this will require
		 *     installing vite.)
		 *
		 * [[DependencyManagement.InstallOnly]]:
		 *   - Same as [[DependencyManagement.Manual]] except that sbt-vite will install
		 *     dependencies from [[npmDependencies]] and [[npmDevDependencies]] at
		 *     [[viteProjectRoot]]
		 *   - This is recommended is you want to manage dependencies using a JS package
		 *     manager to manage dependencies for your project, but you don't want to be
		 *     responsible for installing the packages required by sbt. Note that this will
		 *     change `package.json` and `node_modules` at [[viteProjectRoot]]
		 *
		 * [[DependencyManagement.Managed]]:
		 *   - Dependencies will be fully managed by sbt-vite. All npm dependencies
		 *     imported in the project must be included in [[npmDependencies]]. All
		 *     non-Scala.js sources must be identified in [[viteOtherSources]].
		 *   - No project files will be mutated. All sources from [[viteOtherSources]]
		 *     will be copied to a separate build directory where npm dependencies will
		 *     also be installed.
		 *   - Recommended if you want to control everything from sbt and keep your
		 *     project clean of JS tooling (e.g., package.json, node_modules).
		 *
		 * @see [[DependencyManagement]]
		 */
		val viteDependencyManagement = settingKey[DependencyManagement](
			"How to manage npm dependencies: manually, install-only (semi-manually), or fully automated",
		)

		/**
		 * Where vite will run and install dependencies for "manual" or "install-only"
		 * dependency management. Ignored for "managed" dependency management.
		 *
		 * @see [[Location]]
		 */
		val viteProjectRoot = settingKey[Location](
			"Where to run vite and install dependencies for \"manual\" or \"install-only\" dependency management.",
		)

		/**
		 * Where vite will persist its build. Defaults to:
		 * [project-dir]/target/scala-[x.x.x]/sbt-vite[-test]/bundle/
		 *
		 * @see [[Location]]
		 */
		val viteBundleLocation = settingKey[Location](
			"Location of bundle generated by vite"
		)

		/**
		 * Where generated vite configuration will be kept. Defaults to:
		 * [project-dir]/target/scala-[x.x.x]/sbt-vite[-test]/vite.config.js
		 */
		val viteConfigLocation = settingKey[Location](
			"Location of generated vite config"
		)

		/**
		 * Locations of vite configuration files for overriding default vite test
		 * configuration. These should have the same form as any vite configuration
		 * javascript file except that it should not be wrapped in `defineConfig`.
		 * Instead it should export (default) either a simple `UserConfig` object or a
		 * function from `ConfigEnv` to `UserConfig`. See source:
		 * https://github.com/vitejs/vite/blob/main/packages/vite/src/node/config.ts
		 */
		val viteConfigSources = settingKey[Seq[Location]](
			"Locations of vite configuration files for overriding default vite test configuration",
		)

		/**
		 * Additional sources to be bundled with Scala.js when dependency management is
		 * "managed". Ignored for "manual" and "install-only".
		 *
		 * If a source [[Location]] points to a directory, everything within that directory
		 * will be copied to the build root directory. This means that when importing any
		 * module within such a location, the directory itself should be omitted.
		 *
		 * For instance, if `[project-root]/src/typescript` is one of the locations, and you
		 * want to import from some file
		 * `[project-root]/src/typescript/someModule/someObject.ts`, would use:
		 *
		 * `@JSImport("/someModule/someObject", JSImport.Default)` (for Scala.js)
		 *
		 * or
		 *
		 * `import someObject from '/someModule/someObject';` (for JS).
		 *
		 * If a source [[Location]] points to a non-directory file, that file will
		 * be copied to the build root directory. This means that if one of the
		 * locations is `[project-root]/my-artifacts/index.css`, you can import that
		 * simply as:
		 *
		 * `@JSImport("/index.css?inline", JSImport.Namespace)` (for Scala.js)
		 *
		 * or
		 *
		 * `import '/index.css';` (for JS)
		 */
		val viteOtherSources = settingKey[Set[Location]](
			"Locations of non-scala sources for \"managed\" dependency management",
		)

		/**
		 * Version of vite to use if dependency management is "install-only" or "managed".
		 * Otherwise ignored.
		 */
		val viteVersion = settingKey[String](
			"Version of vite to use, for \"install-only\" or \"auto\" dependency management",
		)

		/**
		 * Npm dependencies to be installed if dependency management is "install-only"
		 * or "managed". Each tuple should have the form `(package, version)` as they
		 * as they would be written in a `package.json` file
		 * (e.g. `{ ..."dependencies": { ... "[package]": "[version]" ... } ... }`)
		 */
		val npmDependencies = settingKey[Seq[(String, String)]](
			"npm dependencies to be installed when using \"install-only\" or \"auto\" dependency management",
		)

		/**
		 * Npm dev dependencies to be installed if dependency management is "install-only"
		 * or "managed". Each tuple should have the form `(package, version)` as they
		 * as they would be written in a `package.json` file
		 * (e.g. `{ ..."devDependencies": { ... "[package]": "[version]" ... } ... }`)
		 */
		val npmDevDependencies = settingKey[Seq[(String, String)]](
			"npm development dependencies to be installed when using \"install-only\" or \"auto\" dependency management",
		)

		/**
		 * Environment variable definitions to be used when running `vite`
		 */
		val viteEnvironment = settingKey[Map[String, String]](
			"Environment variables to be used when running vite",
		)

		/**
		 * Arguments or options to be included when running `vite`
		 */
		val viteExtraArgs = settingKey[Seq[String]](
			"Additional arguments/options to use when running vite build",
		)

		/**
		 * Environment variable definitions to be used when running the `npm`
		 * command
		 */
		val npmEnvironment = settingKey[Map[String, String]](
			"Environment variables to be used when running npm install",
		)

		/**
		 * Arguments or options to be included when running `npm install`
		 */
		val npmExtraArgs = settingKey[Seq[String]](
			"Additional arguments/options to use when running npm install",
		)

		/**
		 * Environment variable definitions to be used when running the `yarn`
		 * command
		 */
		val yarnEnvironment = settingKey[Map[String, String]](
			"Environment variables to be used when running yarn",
		)

		/**
		 * Arguments or options to be included when running `yarn add`
		 */
		val yarnExtraArgs = settingKey[Seq[String]](
			"Additional arguments/options to use when running yarn add",
		)

		val pnpmEnvironment = settingKey[Map[String, String]](
			"Environment variables to be used when running pnpm",
		)

		/**
		 * Arguments or options to be included when running `pnpm add`
		 */
		val pnpmExtraArgs = settingKey[Seq[String]](
			"Additional arguments/options to use when running pnpm install",
		)

		/**
		 * When true, do not generate a vite config. Instead, vite commands will
		 * simply run in [[viteProjectRoot]] without explicitly specifying a vite
		 * config.
		 */
		val viteUseExistingConfig = settingKey[Boolean](
			"Skip config generation and assume existing vite.config.js at viteProjectRoot",
		)

		// Public tasks

		/**
		 * Install all dependencies if using "install-only" or "managed" dependency
		 * management. Ignored otherwise.
		 */
		val viteInstallDependencies = taskKey[Unit](
			"Install npm packages defined in npmDependencies and npmDevDependencies",
		)

		/**
		 * Generates and persists vite configuration file.
		 */
		val viteGenerateConfig = taskKey[Unit](
			"Generate vite configuration for bundling test JS sources into executable test script",
		)

		/**
		 * Moves sources to the build directory, if dependency management is
		 * set to "managed"
		 */
		val vitePrepareSources = taskKey[Unit](
			"Moves sources to the build directory, if dependency management is set to \"managed\"",
		)

		/**
		 * Generates and persists bundle from Scala.js and other sources. Depends
		 * on [[viteGenerateConfig]] and [[viteInstallDependencies]].
		 */
		val viteBuild = taskKey[Unit](
			"Run vite build on all web artifacts",
		)

		/**
		 * Starts a vite development server. Depends
		 * * on [[viteGenerateConfig]] and [[viteInstallDependencies]].
		 */
		val viteDevServer = taskKey[Unit](
			"Start a development server using vite"
		)
	}

	// Private settings

	private[sbtvite] val viteTargetDirectory = SettingKey[File](
		"viteTargetDirectory",
		"Directory where vite build artifacts will be persisted",
		KeyRanks.Invisible,
	)

	private[sbtvite] val viteExecutionDirectory = SettingKey[File](
		"viteExecutionDirectory",
		"Directory where vite will be run",
		KeyRanks.Invisible,
	)

	private[sbtvite] val viteBundleDirectoryName = SettingKey[String](
		"bundleDirectoryName",
		"Name of the directory where the generated bundle is stored",
		KeyRanks.Invisible,
	)

	private [sbtvite] val viteBundleDirectory = SettingKey[File](
		"viteBundleDirectory",
		"Directory where the generated bundle is stored",
		KeyRanks.Invisible,
	)

	private[sbtvite] val bundleFilename = SettingKey[String](
		"bundleFilename",
		"Filename of the generated bundle",
		KeyRanks.Invisible,
	)

	private[sbtvite] val viteConfigName = SettingKey[String](
		"viteConfigName",
		"Filename of the generated vite configuration",
		KeyRanks.Invisible,
	)

	import autoImport.*

	private val testSettings = Seq(
		viteUseExistingConfig := false,

		viteTargetDirectory :=
		  target.value / s"scala-${scalaVersion.value}" / "sbt-vite-test",

		viteExecutionDirectory := {
			(Test / viteDependencyManagement).value match {
				case DependencyManagement.Managed(_) =>
					viteTargetDirectory.value
				case _ => viteProjectRoot.value.resolve(file("."), baseDirectory.value)
			}
		},

		viteExtraArgs ++=
		  (Compile / viteExtraArgs).value ++
			Seq("--mode=development"),

		viteOtherSources := (Compile / viteOtherSources).value,

		jsEnvInput := List(
			Input.Script(
				(Test / viteBundleLocation)
				  .value
				  .resolve(file("."), baseDirectory.value)
				  .toPath,
			),
		),

		npmDevDependencies := (Compile / npmDevDependencies).value ++
		  Seq(
			  "lodash" -> "^4.17.21",
			  "rollup-plugin-sourcemaps" -> "^0.6.3",
			  "vite" -> (Test / viteVersion).value,
		  ),

		viteEnvironment := (Compile / viteEnvironment).value ++
		  Map("NODE_ENV" -> "development"),

		viteInstallDependencies := {
			(Test / viteDependencyManagement).value match {
				case DependencyManagement.Manual => {}
				case DependencyManagement.InstallOnly(manager) =>
					val executor = NpmExecutor(manager)
					val dependencies = (Test / npmDependencies).value.toMap
					val devDependencies = (Test / npmDevDependencies).value.toMap
					val cwd = Some((Test / viteProjectRoot).value.resolve(file("."), baseDirectory.value))
					val (options, environment) = manager match {
						case NpmManager.Yarn =>
							(Test / yarnExtraArgs).value -> (Test / yarnEnvironment).value
						case NpmManager.Npm =>
							(Test / npmExtraArgs).value -> (Test / npmEnvironment).value
						case NpmManager.Pnpm =>
							(Test / pnpmExtraArgs).value -> (Test / pnpmEnvironment).value
					}
					executor.install(dependencies, devDependencies, options, environment, cwd) match {
						case Left(msg) => new MessageOnlyException(msg)
						case _ => ()
					}

				case DependencyManagement.Managed(manager) =>
					val packageJson = """{ "type": "module" }"""
					val executor = NpmExecutor(manager)
					val dependencies = (Test / npmDependencies).value.toMap
					val devDependencies = (Test / npmDevDependencies).value.toMap
					val execDirectory = (Test / viteExecutionDirectory).value
					val cwd = Some(execDirectory)
					import scala.sys.process._
					cwd.foreach(IO.createDirectory)
					Process("mkdir node_modules", cwd).run.exitValue()
					IO.write(execDirectory / "package.json", packageJson.getBytes())
					val (options, environment) = manager match {
						case NpmManager.Yarn =>
							(Test / yarnExtraArgs).value -> (Test / yarnEnvironment).value
						case NpmManager.Npm =>
							(Test / npmExtraArgs).value -> (Test / npmEnvironment).value
						case NpmManager.Pnpm =>
							(Test / pnpmExtraArgs).value -> (Test / pnpmEnvironment).value
					}
					executor
					  .install(dependencies, devDependencies, options, environment, cwd) match {
						case Left(msg) => new MessageOnlyException(msg)
						case _ => ()
					}
			}
		},

		viteGenerateConfig := {
			if ((Test / viteUseExistingConfig).value) {}
			else {
				val rootDirPath = (Test / viteExecutionDirectory).value
				val linkOutputDir = (Test / fastLinkJS / scalaJSLinkerOutputDirectory)
				  .value.toPath
				  .toAbsolutePath
				val inputPath = linkOutputDir / "main.js"
				val outDir = (Test / viteBundleDirectory).value.toPath.toAbsolutePath
				val requiredImports = List(
					"""import _ from 'lodash'""",
					"""import { defineConfig } from "vite";""",
					"""import sourcemaps from 'rollup-plugin-sourcemaps';""",
				)

				val configString =
					ViteConfigGen.generate(
						(Test / viteConfigSources).value.toList.map(_.resolve(file("."), baseDirectory.value).toString),
						rootDirPath.toString,
						Some(inputPath.toString),
						outDir.toString,
						requiredImports,
						Nil,
						List("sourcemaps()"),
					).fold(err => throw new IllegalArgumentException(err.message), identity)

				val configFile = (Test / viteConfigLocation)
				  .value
				  .resolve(file("."), baseDirectory.value)
				IO.write(configFile, configString)
			}
		},

		vitePrepareSources / fileInputs := {
			val sources = (Test / viteOtherSources)
			  .value
			  .toList
			  .map(_.resolve(file("."), baseDirectory.value))

			SourceInjector.impl.sourceGlobs(sources)
		},

		vitePrepareSources := {
			if (
				(Test / vitePrepareSources).inputFileChanges.hasChanges
			)
			(Test / viteDependencyManagement).value match {
				case DependencyManagement.Manual => {}
				case DependencyManagement.InstallOnly(_) => {}
				case DependencyManagement.Managed(_) =>
					val injector = SourceInjector.impl
					val sources = (Test / viteOtherSources)
					  .value
					  .toList
					  .map(_.resolve(file("."), baseDirectory.value))

					val target = (Test / viteExecutionDirectory).value

					injector.inject(sources, target) match {
						case Right(_) => {}
						case Left(msg) =>
							throw new MessageOnlyException(msg)
					}
			}
		},

		viteBuild / fileInputs ++= Seq(
			(Test / viteConfigLocation)
			  .value
			  .resolve(file("."), baseDirectory.value)
			  .toString,
			(Test / fastLinkJS / scalaJSLinkerOutputDirectory).value.toPath.toString + "/*.js",
			(Test / viteExecutionDirectory).value.absolutePath.stripSuffix("/") + "/package*.json",
		),

		viteBuild := {
			// Only bundle if there is a new configuration, there are new test compilation outputs
			// or the bundled output is missing
			if ( {
				(Test / viteBuild).inputFileChanges.hasChanges
			} || {
				Try(IO
				  .read(
					  (Test / viteBundleLocation).value
						.resolve(file("."), baseDirectory.value)
				  ),
				).isFailure
			}) {
				val configPath = (Test / viteConfigLocation)
				  .value
				  .resolve(file("."), baseDirectory.value)
				  .toPath
				  .toString
				val viteCwd = (Test / viteExecutionDirectory)
				  .value
				val npmEnv = (Test / npmEnvironment).value
				val yarnEnv = (Test / yarnEnvironment).value
				val pnpmEnv = (Test / pnpmEnvironment).value
				val packageAndModule = "vite"
				val viteArgs = (Test / viteExtraArgs).value
				val viteEnv = (Test / viteEnvironment).value

				val (executor, managerOpt) = (Test / viteDependencyManagement).value match {
					case DependencyManagement.Manual => (NpmNpmExecutor, None)
					case DependencyManagement.InstallOnly(manager) =>
						(NpmExecutor(manager), Some(manager))
					case DependencyManagement.Managed(manager) =>
						(NpmExecutor(manager), Some(manager))
				}

				val command =
					if ((Test / viteUseExistingConfig).value)
						s"build" +: viteArgs
					else s"build -c $configPath" +: viteArgs

				val managerEnv = viteEnv ++ (managerOpt match {
					case None => Nil
					case Some(NpmManager.Npm) => npmEnv
					case Some(NpmManager.Yarn) => yarnEnv
					case Some(NpmManager.Pnpm) => pnpmEnv
				})

				val result = executor.run(
					packageAndModule,
					packageAndModule,
					command,
					viteEnv ++ managerEnv,
					Some(viteCwd),
				)

				result match {
					case Right(_) => {}
					case Left(message) =>
						throw new MessageOnlyException(message)
				}
			} else {}
		},

		viteBuild := (Test / viteBuild)
		  .dependsOn(
			  Test / viteGenerateConfig,
			  Test / viteInstallDependencies,
			  Test / vitePrepareSources,
			  Test / fastLinkJS,
		  )
		  .value,

		Test / test := (Test / test).dependsOn(Test / viteBuild).value,
	)

	private val compileSettings = Seq(
		viteUseExistingConfig := viteUseExistingConfig.value,

		viteTargetDirectory :=
		  target.value / s"scala-${scalaVersion.value}" / "sbt-vite",

		viteExecutionDirectory := {
			(Compile / viteDependencyManagement).value match {
				case DependencyManagement.Managed(_) =>
					viteTargetDirectory.value
				case _ =>
					viteProjectRoot.value.resolve(file("."), baseDirectory.value)
			}
		},

		viteExtraArgs := Nil,

		viteOtherSources := viteOtherSources.value,

		jsEnvInput := List(
			Input.Script(
				(Compile / viteBundleLocation)
				  .value
				  .resolve(file("."), baseDirectory.value)
				  .toPath,
			),
		),

		viteEnvironment := Map.empty,

		npmDevDependencies := Seq(
			"lodash" -> "^4.17.21",
			"vite" -> (Test / viteVersion).value,
			"@scala-js/vite-plugin-scalajs" -> "1.0.0",
		),

		viteInstallDependencies := {
			viteDependencyManagement.value match {
				case DependencyManagement.Manual => {}
				case DependencyManagement.InstallOnly(manager) =>
					val executor = NpmExecutor(manager)
					val dependencies = (Compile / npmDependencies).value.toMap
					val devDependencies = (Compile / npmDevDependencies).value.toMap
					val cwd = Some((Compile / viteProjectRoot).value.resolve(file("."), baseDirectory.value))
					val (options, environment) = manager match {
						case NpmManager.Yarn =>
							(Compile / yarnExtraArgs).value -> (Compile / yarnEnvironment).value
						case NpmManager.Npm =>
							(Compile / npmExtraArgs).value -> (Compile / npmEnvironment).value
						case NpmManager.Pnpm =>
							(Compile / pnpmExtraArgs).value -> (Compile / pnpmEnvironment).value
					}
					executor.install(dependencies, devDependencies, options, environment, cwd) match {
						case Left(msg) => new MessageOnlyException(msg)
						case _ => ()
					}

				case DependencyManagement.Managed(manager) =>
					val packageJson = """{ "type": "module" }"""
					val executor = NpmExecutor(manager)
					val dependencies = npmDependencies.value.toMap
					val devDependencies = npmDevDependencies.value.toMap
					val execDirectory = viteTargetDirectory.value
					val cwd = Some(execDirectory)
					import scala.sys.process._

					cwd.foreach(IO.createDirectory)
					Process("mkdir node_modules", cwd).run.exitValue()
					IO.write(execDirectory / "package.json", packageJson.getBytes())
					val (options, environment) = manager match {
						case NpmManager.Yarn =>
							yarnExtraArgs.value -> yarnEnvironment.value
						case NpmManager.Npm =>
							npmExtraArgs.value -> npmEnvironment.value
						case NpmManager.Pnpm =>
							pnpmExtraArgs.value -> pnpmEnvironment.value
					}
					executor
					  .install(dependencies, devDependencies, options, environment, cwd) match {
						case Left(msg) => new MessageOnlyException(msg)
						case _ => ()
					}
			}
		},

		viteGenerateConfig := {
			if ((Compile / viteUseExistingConfig).value) {}
			else {
				val rootDirPath = (Compile / viteExecutionDirectory).value
				val outDir = (Compile / viteBundleDirectory).value.toPath.toAbsolutePath
				val isManaged = (Compile / viteDependencyManagement).value match {
					case DependencyManagement.Managed(manager) => true
					case _ => false
				}
				val requiredImports = List(
					"""import _ from 'lodash'""",
					"""import { defineConfig } from "vite";""",
					"""import scalaJSPlugin from "@scala-js/vite-plugin-scalajs";"""
				)

				val plugins = List(
					s"""scalaJSPlugin({ projectId: "${name.value}", cwd: "${file(".").toPath.toAbsolutePath}" })""",
				)

				val configString =
					ViteConfigGen.generate(
						(Compile / viteConfigSources).value.toList.map(_.resolve(file("."), baseDirectory.value).toString),
						rootDirPath.toString,
						None,
						outDir.toString,
						requiredImports,
						plugins,
						development = false,
					).fold(err => throw new IllegalArgumentException(err.message), identity)

				val configFile = (Compile / viteConfigLocation)
				  .value
				  .resolve(file("."), baseDirectory.value)
				IO.write(configFile, configString)
			}
		},

		vitePrepareSources / fileInputs := {
			val sources = (Compile / viteOtherSources)
			  .value
			  .toList
			  .map(_.resolve(file("."), baseDirectory.value))

			val globs = SourceInjector.impl.sourceGlobs(sources)
			globs.foreach(println)
			globs
		},

		vitePrepareSources := {
			if (
				(Compile / vitePrepareSources).inputFileChanges.hasChanges
			)
				(Compile / viteDependencyManagement).value match {
					case DependencyManagement.Manual => {}
					case DependencyManagement.InstallOnly(_) => {}
					case DependencyManagement.Managed(_) =>
						val injector = SourceInjector.impl
						val sources = (Compile / viteOtherSources)
						  .value
						  .toList
						  .map(_.resolve(file("."), baseDirectory.value))

						val target = (Compile / viteExecutionDirectory).value

						injector.inject(sources, target) match {
							case Right(_) => {}
							case Left(msg) =>
								throw new MessageOnlyException(msg)
						}
				}
		},

		viteBuild / fileInputs ++= Seq(
			(Compile / viteConfigLocation)
			  .value
			  .resolve(file("."), baseDirectory.value)
			  .toString,
			(Compile / fastLinkJS / scalaJSLinkerOutputDirectory).value.toPath.toString + "/*.js",
			(Compile / viteExecutionDirectory).value.absolutePath.stripSuffix("/") + "/package*.json",
		),

		viteBuild := {
			// Only bundle if there is a new configuration, there are new test compilation outputs
			// or the bundled output is missing
			if ( {
				(Compile / viteBuild).inputFileChanges.hasChanges
			} || {
				Try(IO
				  .read(
					  (Compile / viteBundleLocation).value
												 .resolve(file("."), baseDirectory.value)
				  ),
				).isFailure
			}) {
				val configPath = (Compile / viteConfigLocation)
				  .value
				  .resolve(file("."), baseDirectory.value)
				  .toPath
				  .toString
				val viteCwd = (Compile / viteExecutionDirectory)
				  .value
				val npmEnv = (Compile / npmEnvironment).value
				val yarnEnv = (Compile / yarnEnvironment).value
				val pnpmEnv = (Compile / pnpmEnvironment).value
				val packageAndModule = "vite"
				val viteArgs = (Compile / viteExtraArgs).value
				val viteEnv = (Compile / viteEnvironment).value

				val (executor, managerOpt) = (Compile / viteDependencyManagement).value match {
					case DependencyManagement.Manual =>
						(NpmNpmExecutor, None)
					case DependencyManagement.InstallOnly(manager) =>
						(NpmExecutor(manager), Some(manager))
					case DependencyManagement.Managed(manager) =>
						(NpmExecutor(manager), Some(manager))
				}

				val command =
					if ((Compile / viteUseExistingConfig).value)
						s"build" +: viteArgs
					else s"build -c $configPath" +: viteArgs

				val managerEnv = viteEnv ++ (managerOpt match {
					case None => Nil
					case Some(NpmManager.Npm) => npmEnv
					case Some(NpmManager.Yarn) => yarnEnv
					case Some(NpmManager.Pnpm) => pnpmEnv
				})

				val result = executor.run(
					packageAndModule,
					packageAndModule,
					command,
					viteEnv ++ managerEnv,
					Some(viteCwd),
				)

				result match {
					case Right(_) => {}
					case Left(message) =>
						throw new MessageOnlyException(message)
				}
			} else {}
		},

		viteBuild := (Compile / viteBuild)
		  .dependsOn(
			  Compile / viteGenerateConfig,
			  Compile / viteInstallDependencies,
			  Compile / vitePrepareSources,
			  Compile / fastLinkJS,
		  )
		  .value,

		viteDevServer := {
			val configPath = (Compile / viteConfigLocation)
			  .value
			  .resolve(file("."), baseDirectory.value)
			  .toPath
			  .toString
			val viteCwd = (Compile / viteExecutionDirectory)
			  .value
			val npmEnv = (Compile / npmEnvironment).value
			val yarnEnv = (Compile / yarnEnvironment).value
			val pnpmEnv = (Compile / pnpmEnvironment).value
			val packageAndModule = "vite"
			val viteArgs = (Compile / viteExtraArgs).value
			val viteEnv = (Compile / viteEnvironment).value

			val (executor, managerOpt) = (Compile / viteDependencyManagement).value match {
				case DependencyManagement.Manual =>
					(NpmNpmExecutor, None)
				case DependencyManagement.InstallOnly(manager) =>
					(NpmExecutor(manager), Some(manager))
				case DependencyManagement.Managed(manager) =>
					(NpmExecutor(manager), Some(manager))
			}

			val command =
				if ((Compile / viteUseExistingConfig).value)
					viteArgs
				else s"-c $configPath" +: viteArgs

			val managerEnv = viteEnv ++ (managerOpt match {
				case None => Nil
				case Some(NpmManager.Npm) => npmEnv
				case Some(NpmManager.Yarn) => yarnEnv
				case Some(NpmManager.Pnpm) => pnpmEnv
			})

			val process = executor.runProcess(
				packageAndModule,
				packageAndModule,
				command,
				viteEnv ++ managerEnv,
				Some(viteCwd),
			)

			scala.io.StdIn.readLine("Running vite dev server. Press enter to close")
			println("Closing dev server...")
			while (process.isAlive()) {
				process.destroy()
			}
			println("...Closed")
			process.exitValue()
		},

		viteDevServer := (Compile / viteDevServer)
		  .dependsOn(
			  Compile / viteGenerateConfig,
			  Compile / viteInstallDependencies,
			  Compile / vitePrepareSources,
		  )
		  .value,

	)

	private val perConfigSettings = Seq(
		viteDependencyManagement := viteDependencyManagement.value,

		viteVersion := viteVersion.value,

		viteProjectRoot := viteProjectRoot.value,

		viteBundleDirectory :=
		  viteTargetDirectory.value / viteBundleDirectoryName.value,

		bundleFilename := "main.js",

		viteBundleLocation := Location.FromCwd(
			viteBundleDirectory.value / bundleFilename.value,
		),

		viteBundleDirectoryName := "bundle",

		viteConfigName := "vite.config.js",

		viteConfigLocation := Location.FromCwd(
			viteTargetDirectory.value / viteConfigName.value,
		),

		viteConfigSources := viteConfigSources.value,

		npmDependencies := npmDependencies.value,

		npmEnvironment := npmEnvironment.value,
		yarnEnvironment := yarnEnvironment.value,
		pnpmEnvironment := pnpmEnvironment.value,

		npmExtraArgs := npmExtraArgs.value,
		yarnExtraArgs := yarnExtraArgs.value,
		pnpmExtraArgs := pnpmExtraArgs.value,
	)

	override lazy val projectSettings = Seq(
		viteDependencyManagement := DependencyManagement.Managed(NpmManager.Npm),

		viteVersion := "^5.0.12",

		viteProjectRoot := Location.ProjectRoot,

		viteUseExistingConfig := false,

		vitePrepareSources := (Compile / vitePrepareSources).value,
		viteInstallDependencies := (Compile / viteInstallDependencies).value,
		viteGenerateConfig := (Compile / viteGenerateConfig).value,
		viteBuild := (Compile / viteBuild).value,

		viteConfigSources := Nil,
		viteOtherSources := Set.empty,

		npmDependencies := Nil,
		npmDevDependencies := Nil,

		viteEnvironment := Map.empty,
		npmEnvironment := Map.empty,
		yarnEnvironment := Map.empty,
		pnpmEnvironment := Map.empty,
		viteExtraArgs := Nil,
		npmExtraArgs := Nil,
		yarnExtraArgs := Nil,
		pnpmExtraArgs := Nil,
	) ++
	  inConfig(Test)(perConfigSettings ++ testSettings) ++
	  inConfig(Compile)(perConfigSettings ++ compileSettings)
}
